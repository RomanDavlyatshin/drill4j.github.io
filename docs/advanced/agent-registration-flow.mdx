---
id: agent-registration-flow
title: Agent registration flow
---
import { Image } from '@components';
import { Info } from '@components';

<Image src="img/for-development/agent-registration-sequence.png" />


Short description for main repos:
- Drill – contains all common actions for agent, plugin repos
- admin - The backend core part of Drill4J, based on Ktor framework.
- Agent – common repo, that describe primitive actions for all agents
- Java-agent – implementation of agent repo.
- test2code-plugin – Плагин для анализа покрытия кода в JVM-based приложениях.


Начинается всё с того, что стартует java-agent. Java-agent является частной имплементацией agent. Agent стартует с метода agentOnLoad() (Starter.kt).
agentOnLoad() – на данном методе происходит парсинг и установка всех передаваемых аргементов (ссылка на все параметры для агента),
так же происходит инициализация jvmtiCapabilities, в которых устанавливается возможность перегружать классы в памяти JVM и поддержка
предустановленного порядка методов, инициализируется bootstrap classloader, регистрируются коллбеки. В коллбеках важна установка jvmtiEventCallbacks,
таких как: VMInit, VMDeath, ClassFileLoadHook, все они отвечают за определённый момент работы JVM:
- jvmtiEventVMInitEvent – в нём происходит инициализация рантайма(если его ещё нет), конфигурирования http(при установленном http hook параметре),
загрузка либы агента, так же устанавливается соединение с admin через веб-сокеты и ждёт пока не будет подтверждения на подключение.
- vmDeathEvent – в нём происходит вывод сообщение о том, что JVM умирает(no magic).
- classLoadEvent – этот ивент отрабатывает на подгрузке любого класса JVMом, здесь и происходит инструментация классов при помощи asm (у нас написана кастомная версия asm путём переписывания исходных классов на котлин).
После даётся команда на то, чтобы оповестить о загрузке JVMTI. Всё, агент ждёт, пока поднимется admin для соединения с ним.


Admin – это большое монолитное приложение на Kotlin с использованием Ktor (движок Netty) и Kodein. Стартует оно с метода Application.module(),
где происходит загрузка основных частей приложения:
- StatusPages
- CallLogging
- Locations
- WebSockets
- ContentNegotiation
- Swagger
- Authentication
- CORS
- DI modules (Kodein)
//TODO добавить ссылки на каждый компонет


Принимает admin запрос на соединение с agent в AgentHandler, на сокете «/agent/attach», т.к у нас java-agent,
то общение между собой они будут поддерживать через тип данных Binary (при NodeJS - TEXT), тут же стартует сессия для WS и аттач агента, создание ws-loop.
WsLoop будет обрабатывать все приходящие MessageType: PLUGIN_DATA, MESSAGE_DELIVERED, START_CLASSES_TRANSFER, CLASSES_DATA, FINISH_CLASSES_TRANSFER.
В это время происходит загрузка плагина, в зависимости от установленного флага, он либо берётся из локального фолдера, либо из artifactory и перемещается
в adminStorage (фолдер, который создаётся на этапе скачивания плагина), после установки плагина, можем вернутся в момент attach, т.к при аттаче агента
происходит и инициализация плагина (initPlugins-> ensurePluginInstance метод), в процессе инициализации создаётся инстанс плагина и вызвается на нём initialize() метод.

Admin-UI отправляет запрос на регистрацию агента, во время этого процесса создаётся инстанс необходимого плагина или плагинов
и происходит синхронизация данных (sync метод). Во время процесса sync() агенту отправляются:
- Префикс пакета
- Плагин, который выбрали (На стороне агента плагин загружается в память и инициализируется initPlugin())
- Запрос на передачу классов
- Включение пересланных плагинов

Теперь подробно про каждый этап.

### Префикс пакета:
Во время этого процесса в конфиг агента добавляется строка с путём к определённому пакету, с него и будут браться все файлы для плагина.

### Отправка плагина:
В основном плагин состоит из admin-part и agent-part, все операции, что будут происходить между агентом и плагином выполняются agent-part, а части, которые относятся к admin и плагину будут выполнятся admin-part.
Во время процесса отправки плагинов, которые были выбраны на этапе регистрации агента, будут отправлены при помощи PluginLoadEvent и на стороне агента получаемый плагин загрузится в память, после чего будут вызваны метод initPlugin() и on().

initPlugin() – запускает ретрансформацию классов. Что такое ретрансформация классов? В данном коде метод RetransformClasses используется
для повторной трансформации классов, которые находятся в списке loaded. Параметр loaded является массивом, который содержит адреса (в виде CPointer) классов,
которые нужно повторно трансформировать. Параметр loaded.size указывает количество классов, которые нужно повторно трансформировать. При выполнении метода,
JVM проверяет и повторно трансформирует классы, переданные в параметре loaded. Если трансформация прошла успешно, то новые изменения байт-кода становятся
активными после перезагрузки классов в памяти JVM.

On() - выполняет инициализацию плагина, проверяет на то была-ли инициализация или нет и отправляет соответствующие сообщения(Initialized про него позже) на admin-part плагину.
После выполнения этих методов агент сообщает admin про то, что плагин успешно загружен и admin отправляет сообщение о том, что хочет получить классы по префиксу.

### Передача классов:
Начинается всё с того, что admin часть сообщает агента про то, что хочет получить классы(triggerClassesSending). Агент получив триггер сообщает о том, что сейчас отправит классы START_CLASSES_TRANSFER
и после чего начинает отправку классов в CLASSES_DATA топик, после окончания отправки всех найденных классов сообщается о том,
что отправка классов завершена FINISH_CLASSES_TRANSFER. Admin после того, как получил все классы начинает их сохранять в бд (initClasses()).

### Включение пересланных плагинов:
После получения всех классов в «сыром» виде идёт запрос на включение плагина от admin к agent, во время этого процесса снова вызывается метод on().
Как уже писалось выше на моменте вызова метода on() отправляется информация на admin про то,
что плагин проинициализирован – Initialized, после чего происходит инициализация основных блоков плагина:
- Parse ClassBytes to ClassData
- initGateSettings and sendGateSettings
- sendParentBuild
- sendBaseLine
- sendParentTestsToRunStats
- sendBuildStats
- sendScopes
- calculateAndSendCachedCoverage
- sendLabels
- sendFilters
//TODO написать про каждый метод
