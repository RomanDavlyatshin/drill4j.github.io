---
id: agent-registration-flow
title: Agent registration flow
---





import {Image, Info} from '@components';

<Image src="img/for-development/agent-registration-sequence.png"/>


Постановка проблемы:
Регистрация необходима для установки плагина и передачи указания фильтра пакетов на сторону агента.

<Info>
    Short description for main repos:
    Drill – contains all common actions for agent, plugin repos;
    admin - The backend core part of Drill4J, based on Ktor framework;
    Agent – common repo, that describe primitive actions for all agents;
    Java-agent – implementation of agent repo;
    test2code-plugin – Плагин для анализа покрытия кода в JVM-based приложениях.
</Info>

## Этапы регистрации агента:
### Создания предусловий:
1. Старт таргет приложения с агентом, старт админ части drill
2. Аттач агента к админке через WebScoket
### Регистрация агента в админке:
1. Запрос на регистрацию агента в админке
2. Отправка префикса пакета
3. Отправка плагина
4. Передача классов
5. Включение пересланных плагинов

## Создания предусловий
### Старт таргет приложения с агентом, старт админ части drill
#### Старт агента и его начальная инициализация
Начинается всё с того, что стартует java-agent на target приложении(Agent стартует с метода agentOnLoad() (Starter.kt)).
agentOnLoad() – на данном методе происходит парсинг и установка всех передаваемых аргументов (//TODO добавить ссылку на все параметры для агента),
так же происходит инициализация jvmtiCapabilities, в которых устанавливается возможность перегружать классы в памяти JVM и поддержка
предустановленного порядка методов, инициализируется bootstrap classloader, регистрируются callbacks. В callbacks важна установка jvmtiEventCallbacks,
таких как: VMInit, VMDeath, ClassFileLoadHook, все они отвечают за определённый момент работы JVM:
- jvmtiEventVMInitEvent – в нём происходит инициализация рантайма(если его ещё нет), конфигурирования http(при установленном http hook параметре),
загрузка либы агента, так же устанавливается соединение с admin через веб-сокеты и ждёт пока не будет подтверждения на подключение.
- vmDeathEvent – в нём происходит вывод сообщение о том, что JVM умирает(no magic).
- classLoadEvent – этот ивент отрабатывает на подгрузке любого класса JVMом, здесь и происходит инструментация классов при помощи asm (у нас написана кастомная версия asm путём переписывания исходных классов на котлин).
После даётся команда на то, чтобы оповестить о загрузке JVMTI. Всё, агент ждёт, пока поднимется admin для соединения с ним.
### Старт админ части drill
Admin – это большое монолитное приложение на Kotlin с использованием Ktor (движок Netty) и Kodein. Стартует оно с метода Application.module(),
где происходит загрузка основных частей приложения:
- <a href="https://ktor.io/docs/status-pages.html">StatusPages</a>
- <a href="https://ktor.io/docs/call-logging.html">CallLogging</a>
- <a href="https://ktor.io/docs/locations.htmll">Locations</a>
- <a href="https://ktor.io/docs/websocket.html">WebSockets</a>
- <a href="https://ktor.io/docs/status-pages.html">ContentNegotiation</a>
- <a href="https://ktor.io/docs/serialization.html">Swagger</a>
- <a href="https://ktor.io/docs/authentication.html">Authentication</a>
- <a href="https://ktor.io/docs/cors.html">CORS</a>
-  DI modules <a href="https://github.com/kosi-libs/Kodein">Kodein</a>
После базовой прогрузки основных модулей Ktor admin принимает запрос на соединение с agent в AgentHandler (на сокете «/agent/attach»), т.к у нас java-agent,
то общение между собой они будут поддерживать через тип данных Binary (при NodeJS - TEXT), тут же стартует сессия для WS и аттач агента, создание ws-loop.
WsLoop будет обрабатывать все приходящие MessageType: PLUGIN_DATA, MESSAGE_DELIVERED, START_CLASSES_TRANSFER, CLASSES_DATA, FINISH_CLASSES_TRANSFER.
В это время происходит загрузка плагина. Плагин может быть установлен как из артифактори, так и из локального хранилища.
После установки плагина, создаётся его инстанс (initPlugins-> ensurePluginInstance метод) и вызывается инициализация admin-part плагина (initialize() метод).

## Регистрация агента в админке:
### Запрос на регистрацию агента в админке
Admin-UI отправляет запрос на регистрацию агента, во время этого процесса создаётся инстанс необходимого плагина или плагинов
и происходит синхронизация данных (sync метод). Во время процесса sync() агенту отправляются:
- Префикс пакета
- Плагин, который выбрали (На стороне агента плагин загружается в память и инициализируется initPlugin())
- Запрос на передачу классов
- Включение пересланных плагинов

Теперь подробно про каждый этап.
### Префикс пакета:
Во время этого процесса в конфиг агента добавляется строка с путём к определённому пакету, с него и будут браться все файлы/классы для
анализа плагином или обработкой на стороне admin.

### Отправка плагина:
В основном плагин состоит из admin-part и agent-part, все операции, что будут происходить между агентом и плагином выполняются agent-part,
а части, которые относятся к admin и плагину будут выполнятся admin-part.
Во время процесса отправки плагинов, которые были выбраны на этапе регистрации агента,
будут отправлены при помощи PluginLoadEvent и на стороне агента получаемый плагин загрузится в память,
после чего будут вызваны метод initPlugin() и on().


initPlugin() – запускает ретрансформацию классов после инструментации. Что такое ретрансформация классов? Метод RetransformClasses используется
для повторной загрузки классов, которые находятся в JVM памяти. Если трансформация прошла успешно, то новые изменения байт-кода становятся
активными после перезагрузки классов в памяти JVM.

On() - выполняет инициализацию плагина, проверяет на то была-ли инициализация или нет и отправляет соответствующие сообщения(Initialized про него позже) на admin-part плагину.
После выполнения этих методов агент сообщает admin про то, что плагин успешно загружен и admin отправляет сообщение о том, что хочет получить классы по префиксу.

### Передача классов:
Начинается всё с того, что admin часть сообщает агента про то, что хочет получить классы(triggerClassesSending). Агент получив триггер сообщает о том, что сейчас отправит классы START_CLASSES_TRANSFER
и после чего начинает отправку классов в CLASSES_DATA топик, после окончания отправки всех найденных классов сообщается о том,
что отправка классов завершена FINISH_CLASSES_TRANSFER. Admin после того, как получил все классы начинает их сохранять в бд (initClasses()).

### Включение пересланных плагинов:
После получения всех классов в «сыром» виде идёт запрос на включение плагина от admin к agent, во время этого процесса снова вызывается метод on().
Как уже писалось выше на моменте вызова метода on() отправляется информация на admin про то,
что плагин проинициализирован – Initialized, после чего происходит инициализация основных блоков плагина:
- Parse ClassBytes to ClassData
- initGateSettings and sendGateSettings
- sendParentBuild
- sendBaseLine
- sendParentTestsToRunStats
- sendBuildStats
- sendScopes
- calculateAndSendCachedCoverage
- sendLabels
- sendFilters

### Parse ClassBytes to ClassData метод
Данный метод получает байты класса в виде Map, где ключем есть имя класса, а значением байты класса
и возвращает ClassData - это объект, который содержит agentKey, packageTree, probeIds.
Механизм получения контекста класса явлается один из ключевых действий в данном методе. Это происходит в методе bundle.
Эта функция возвращает результат типа BundleCounter. Для его получения она сначала создает пустой поток emptySequence типа ExecClassData
и вызывает для него функцию bundle(probeIds), передавая ей карту probeIds и функцию-лямбду
{ analyzer -> forEach { name -> analyzer.analyzeClass(classBytes.getValue(name), name) } }.
Функция-лямбда вызывает метод analyzeClass для каждого элемента итерируемого объекта Iterable типа String,
передавая ему байт-код класса и его имя. Метод analyzeClass выполняет анализ байт-кода класса и возвращает объект типа ExecClassData.
После этого, метод bundle собирает все полученные ExecClassData в бандл (BundleData) и возвращает его в виде BundleCounter.
Метод toCounter(false) вызывается на этом бандле для получения BundleCounter, который возвращается из этой функции и который собственно
достаёт все проанализированные классы и методы из интерфейса IBundleCoverage.

